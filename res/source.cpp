// GENERATED BY JLEX
// COPYRIGHT JinBridge 2023

#include <algorithm>
#include <fstream>
#include <functional>
#include <iostream>
#include <iterator>
#include <map>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

// fa.hpp

// actually, it is a graph
// use '@' for epsilon
struct fa {
    fa(int total_status) : _total_status(total_status), _head(std::vector<int>(total_status, -1)) {
        for (int i = 0; i < total_status; ++i) {
            _accept_status[i] = -1;
        }
    }

    int _total_status = 0;
    // start status is default 0
    // for nfa, accept status is total status - 1
    // for dfa, accept status is _accept_status

    struct edge {
        int  _to, _next;
        char _ch;
    };
    std::vector<int>  _head;
    std::vector<edge> _edge;

    std::set<char> _symbols;
    // std::set<int>      _accept_status;
    // key: status, value: token enum in int
    std::map<int, int> _accept_status;

    void add_edge(int from, int to, char c) {
        _edge.push_back(edge());
        _edge[_edge.size() - 1]._to   = to;
        _edge[_edge.size() - 1]._ch   = c;
        _edge[_edge.size() - 1]._next = _head[from];
        _head[from]                   = _edge.size() - 1;
    }

    void print() {
        for (int i = 0; i < _total_status; ++i) {
            if (_head[i] == -1)
                continue;
            std::cout << "Status " + std::to_string(i) << std::endl;
            for (int idx = _head[i]; idx != -1; idx = _edge[idx]._next)
                std::cout << "    --" << _edge[idx]._ch << "--> " << std::to_string(_edge[idx]._to) << std::endl;
        }
        std::cout << "Accept states:" << std::endl;
        for (auto i : _accept_status)
            std::cout << "    " << i.first << ": " << i.second << std::endl;
    }
};

// regexpr.hpp

struct reg_char {
    reg_char(char v, bool is_op) : _value(v), _is_operator(is_op) {}
    char _value;
    bool _is_operator;
};

struct reg_string {
    std::vector<reg_char> _value;
};

// convert to postfix expr
class regexpr {
public:
    static reg_string convert(std::string regexpr) {
        return convert_to_postfix(add_connect_operator(convert_reg_string(replace_keyword(regexpr))));
    }

    static std::set<char> get_all_character(reg_string regexpr) {
        std::set<char> result;
        for (auto ch : regexpr._value)
            if (!ch._is_operator)
                result.insert(ch._value);
        return result;
    }

private:
    static std::string replace_keyword(std::string regexpr) {
        // replace a-z
        while (true) {
            auto pos = regexpr.find("a-z");
            if (pos == std::string::npos) {
                break;
            }
            regexpr.replace(pos, 3, "a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z");
        }
        // replace A-Z
        while (true) {
            auto pos = regexpr.find("A-Z");
            if (pos == std::string::npos) {
                break;
            }
            regexpr.replace(pos, 3, "A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z");
        }
        // replace 0-9
        while (true) {
            auto pos = regexpr.find("0-9");
            if (pos == std::string::npos) {
                break;
            }
            regexpr.replace(pos, 3, "0|1|2|3|4|5|6|7|8|9");
        }
        return regexpr;
    }

    static reg_string convert_reg_string(std::string regexpr) {
        reg_string result;
        for (int i = 0; i < regexpr.length(); ++i) {
            if (regexpr[i] == '\\') {
                i++;
                if (regexpr[i] == 'n') {
                    result._value.push_back(reg_char('\n', false));
                    continue;
                }
                if (regexpr[i] == 't') {
                    result._value.push_back(reg_char('\t', false));
                    continue;
                }
                result._value.push_back(reg_char(regexpr[i], false));
                continue;
            }
            if (is_regexpr_operator(regexpr[i])) {
                result._value.push_back(reg_char(regexpr[i], true));
            }
            else {
                result._value.push_back(reg_char(regexpr[i], false));
            }
        }
        return result;
    }

    // operator priority: * > | > @
    static reg_string add_connect_operator(reg_string regexpr) {
        reg_string new_regexpr;
        new_regexpr._value.push_back(regexpr._value[0]);
        for (int i = 1; i < regexpr._value.size(); ++i) {
            bool add_connect = false;

            auto curr_char = regexpr._value[i];
            auto last_char = new_regexpr._value[new_regexpr._value.size() - 1];

            // case 1: add between 2 non-operator character
            if (!last_char._is_operator && !curr_char._is_operator)
                add_connect = true;

            // case 2: add between non-operator and '('
            if (!last_char._is_operator && curr_char._is_operator && curr_char._value == '(')
                add_connect = true;

            // case 3: add between ')' and non-operator
            if (last_char._is_operator && last_char._value == ')' && !curr_char._is_operator)
                add_connect = true;

            // case 4: add between '*' and non-operator
            if (last_char._is_operator && last_char._value == '*' && !curr_char._is_operator)
                add_connect = true;

            // case 5: add between '*' and '('
            if (last_char._is_operator && last_char._value == '*' && curr_char._is_operator && curr_char._value == '(')
                add_connect = true;

            if (add_connect)
                new_regexpr._value.push_back(reg_char('@', true));

            new_regexpr._value.push_back(curr_char);
        }
        return new_regexpr;
    }

    static reg_string convert_to_postfix(reg_string regexpr) {
        std::stack<reg_char> operator_stack;
        std::stack<reg_char> intermediate_stack;
        for (int i = 0; i < regexpr._value.size(); ++i) {
            // non-operator
            if (!regexpr._value[i]._is_operator) {
                intermediate_stack.push(regexpr._value[i]);
                continue;
            }

            // left parenthese
            if (regexpr._value[i]._is_operator && regexpr._value[i]._value == '(') {
                operator_stack.push(regexpr._value[i]);
                continue;
            }

            // right parenthese
            if (regexpr._value[i]._is_operator && regexpr._value[i]._value == ')') {
                while (!(operator_stack.top()._value == '(' && operator_stack.top()._is_operator)) {
                    intermediate_stack.push(operator_stack.top());
                    operator_stack.pop();
                }
                operator_stack.pop();
                continue;
            }

            // other operators
            while (!operator_stack.empty() && !(operator_stack.top()._value == '(' && operator_stack.top()._is_operator)
                   && !compare_priority(regexpr._value[i]._value, operator_stack.top()._value)) {
                intermediate_stack.push(operator_stack.top());
                operator_stack.pop();
            }

            operator_stack.push(regexpr._value[i]);
        }
        while (!operator_stack.empty()) {
            intermediate_stack.push(operator_stack.top());
            operator_stack.pop();
        }

        std::stack<reg_char> revert_stack;
        while (!intermediate_stack.empty()) {
            revert_stack.push(intermediate_stack.top());
            intermediate_stack.pop();
        }

        reg_string new_regexpr;
        while (!revert_stack.empty()) {
            new_regexpr._value.push_back(revert_stack.top());
            revert_stack.pop();
        }

        return new_regexpr;
    }

    static bool is_regexpr_operator(char c) {
        if (c == '*' || c == '|' || c == '(' || c == ')' || c == '@')
            return true;
        return false;
    }

    // return true when a has higher priority than b
    static bool compare_priority(char a, char b) {
        auto convert_int = [](char a) -> int {
            switch (a) {
            case '(':
                return 0;
            case '*':
                return -1;
            case '|':
                return -2;
            case '@':
                return -3;
            }
            return 1;
        };

        return convert_int(a) > convert_int(b);
    }
};

// nfa.hpp

// convert regexpr to nfa
class nfa {
public:
    static fa convert(reg_string regexpr, int target_enum) {
        std::stack<fa> stk;
        for (int i = 0; i < regexpr._value.size(); ++i) {
            if (!regexpr._value[i]._is_operator)
                stk.push(create_nfa(regexpr._value[i]._value));

            if (regexpr._value[i]._is_operator && regexpr._value[i]._value == '@') {
                fa b = stk.top();
                stk.pop();
                fa a = stk.top();
                stk.pop();
                stk.push(joint_nfa(a, b));
            }
            if (regexpr._value[i]._is_operator && regexpr._value[i]._value == '|') {
                fa b = stk.top();
                stk.pop();
                fa a = stk.top();
                stk.pop();
                stk.push(union_nfa(a, b));
            }
            if (regexpr._value[i]._is_operator && regexpr._value[i]._value == '*') {
                fa a = stk.top();
                stk.pop();
                stk.push(kleene_nfa(a));
            }
        }
        auto result     = stk.top();
        result._symbols = regexpr::get_all_character(regexpr);

        result._accept_status[result._total_status - 1] = target_enum;
        return result;
    }

    static fa combine_nfas(std::vector<fa> nfas) {
        int total_states = 0;
        for (auto nfa : nfas)
            total_states += nfa._total_status;
        fa  new_nfa(total_states + 1);
        int offset = 1;
        for (auto nfa : nfas) {
            int state_in_nfa = 0;
            for (; state_in_nfa < nfa._total_status; ++state_in_nfa)
                for (int i = nfa._head[state_in_nfa]; i != -1; i = nfa._edge[i]._next) {
                    new_nfa.add_edge(state_in_nfa + offset, nfa._edge[i]._to + offset, nfa._edge[i]._ch);
                }
            for (auto i : nfa._accept_status) {
                new_nfa._accept_status[i.first + offset] = i.second;
            }
            new_nfa.add_edge(0, offset, '@');
            for (auto symbol : nfa._symbols)
                new_nfa._symbols.insert(symbol);
            offset += nfa._total_status;
        }
        return new_nfa;
    }

private:
    // create nfa for each character
    static fa create_nfa(char c) {
        fa new_nfa(2);
        new_nfa.add_edge(0, 1, c);
        return new_nfa;
    }

    static fa union_nfa(fa a, fa b) {
        fa new_nfa(a._total_status + b._total_status + 2);

        // a node: [1, a._total_status]
        // b node: [a._total_status + 1, a._total_status + b._total_status]
        // now combine a:
        int offset_a = 1;
        new_nfa.add_edge(0, 1, '@');
        for (int i = 0; i < a._total_status; ++i)
            for (int idx = a._head[i]; idx != -1; idx = a._edge[idx]._next)
                new_nfa.add_edge(i + offset_a, a._edge[idx]._to + offset_a, a._edge[idx]._ch);
        new_nfa.add_edge(a._total_status - 1 + offset_a, a._total_status + b._total_status + 1, '@');
        // now combine b:
        int offset_b = a._total_status + 1;
        new_nfa.add_edge(0, 0 + offset_b, '@');
        for (int i = 0; i < b._total_status; ++i)
            for (int idx = b._head[i]; idx != -1; idx = b._edge[idx]._next)
                new_nfa.add_edge(i + offset_b, b._edge[idx]._to + offset_b, b._edge[idx]._ch);
        new_nfa.add_edge(b._total_status - 1 + offset_b, a._total_status + b._total_status + 1, '@');

        return new_nfa;
    }

    static fa joint_nfa(fa a, fa b) {
        fa new_nfa(a._total_status + b._total_status - 1);

        // a node: [0, a._total_status - 1]
        // b node: [a._total_status - 1, a._total_status + b._total_status - 2]
        // now joint a:
        int offset_a = 0;
        for (int i = 0; i < a._total_status; ++i)
            for (int idx = a._head[i]; idx != -1; idx = a._edge[idx]._next)
                new_nfa.add_edge(i + offset_a, a._edge[idx]._to + offset_a, a._edge[idx]._ch);
        // now joint b:
        int offset_b = a._total_status - 1;
        for (int i = 0; i < b._total_status; ++i)
            for (int idx = b._head[i]; idx != -1; idx = b._edge[idx]._next)
                new_nfa.add_edge(i + offset_b, b._edge[idx]._to + offset_b, b._edge[idx]._ch);

        return new_nfa;
    }

    static fa kleene_nfa(fa a) {
        fa new_nfa(a._total_status + 3);

        // a node: [2, a._total_status + 1]
        int offset_a = 2;
        new_nfa.add_edge(0, 1, '@');
        new_nfa.add_edge(1, 2, '@');
        for (int i = 0; i < a._total_status; ++i)
            for (int idx = a._head[i]; idx != -1; idx = a._edge[idx]._next)
                new_nfa.add_edge(i + offset_a, a._edge[idx]._to + offset_a, a._edge[idx]._ch);
        new_nfa.add_edge(a._total_status - 1 + offset_a, 1, '@');
        new_nfa.add_edge(1, a._total_status + 2, '@');

        return new_nfa;
    }
};

// dfa.hpp

struct dfa_item {
    dfa_item(int id, int target_enum, std::set<int> states) : _id(id), _target_enum(target_enum), _states(states) {}
    int _id;
    int _target_enum;

    std::set<int> _states;
};

class dfa {
public:
    static fa convert(fa nfa) {
        auto dfa_states            = std::vector<dfa_item>();
        int  total_states          = 0;
        auto start_epsilon_closure = find_epsilon_closure(nfa, 0);
        start_epsilon_closure.insert(0);

        std::vector<std::map<char, int>> table;

        dfa_states.push_back(
            dfa_item(total_states++, get_target_enum(nfa, start_epsilon_closure), start_epsilon_closure));
        int current_state = 0;
        // fill in table
        do {
            table.push_back(std::map<char, int>());
            for (char ch : nfa._symbols) {
                table[current_state][ch] = -1;
            }
            for (char ch : nfa._symbols) {
                auto closure = find_char_closure(nfa, dfa_states[current_state]._states, ch);
                if (closure.size() == 0)
                    continue;
                for (auto state : dfa_states) {
                    if (state._states == closure) {
                        table[current_state][ch] = state._id;
                        goto next_char;
                    }
                }
                // new state
                dfa_states.push_back(dfa_item(total_states++, get_target_enum(nfa, closure), closure));
                table[current_state][ch] = total_states - 1;
            next_char:
                continue;
            }
            current_state++;
        } while (current_state != total_states);

        // construct new dfa according to table
        fa new_dfa(total_states);
        for (int from = 0; from < table.size(); ++from)
            for (char ch : nfa._symbols)
                if (table[from][ch] != -1)
                    new_dfa.add_edge(from, table[from][ch], ch);

        // add accept states
        for (auto it : dfa_states)
            if (it._target_enum != -1)
                new_dfa._accept_status[it._id] = it._target_enum;

        new_dfa._symbols = nfa._symbols;
        return new_dfa;
    }

private:
    static std::set<int> find_epsilon_closure(fa nfa, int start) {
        std::set<int>    result;
        std::queue<int>  tmp;
        std::vector<int> visited(nfa._total_status, 0);
        tmp.push(start);
        while (!tmp.empty()) {
            int start = tmp.front();
            tmp.pop();
            if (!visited[start]) {
                for (int i = nfa._head[start]; i != -1; i = nfa._edge[i]._next) {
                    if (nfa._edge[i]._ch == '@') {
                        result.insert(nfa._edge[i]._to);
                        tmp.push(nfa._edge[i]._to);
                    }
                }
                visited[start] = 1;
            }
        }
        return result;
    }

    static std::set<int> find_char_closure(fa nfa, std::set<int> start, char ch) {
        // first get epsilon start
        std::set<int> epsilon_closure_start;
        for (int pt : start)
            for (int i = nfa._head[pt]; i != -1; i = nfa._edge[i]._next)
                if (nfa._edge[i]._ch == ch)
                    epsilon_closure_start.insert(nfa._edge[i]._to);

        // get epsilon closure
        std::set<int> result = epsilon_closure_start;
        for (int pt : epsilon_closure_start) {
            auto          tmp       = find_epsilon_closure(nfa, pt);
            auto          union_tmp = result;
            std::set<int> tmp_result;
            std::set_union(tmp.begin(), tmp.end(), union_tmp.begin(), union_tmp.end(),
                           std::inserter(tmp_result, tmp_result.begin()));
            result = tmp_result;
        }

        return result;
    }

    static int get_target_enum(fa nfa, std::set<int> states) {
        for (auto state : states)
            if (nfa._accept_status[state] != -1)
                return nfa._accept_status[state];
        return -1;
    }
};

// minimize_dfa.hpp

class minimize_dfa {
public:
    static fa convert(fa dfa) {
        auto init_split_group = init_split(dfa);
        auto final_group      = split_group(dfa, init_split_group);

        final_group = move_forward_zero(final_group);
        fa new_dfa(final_group.size());

        std::set<std::tuple<int, int, char>> add_buffer;

        for (int from = 0; from < final_group.size(); ++from) {
            for (auto state : final_group[from]) {
                for (int i = dfa._head[state]; i != -1; i = dfa._edge[i]._next) {
                    int dst = in_which_group(final_group, dfa._edge[i]._to);
                    int ch  = dfa._edge[i]._ch;
                    add_buffer.insert(std::tuple<int, int, char>(from, dst, ch));
                }
            }
        }

        for (auto param : add_buffer) {
            new_dfa.add_edge(std::get<0>(param), std::get<1>(param), std::get<2>(param));
        }

        for (auto i : dfa._accept_status)
            new_dfa._accept_status[in_which_group(final_group, i.first)] = i.second;
        return new_dfa;
    }

private:
    static std::vector<std::vector<int>> init_split(fa dfa) {
        // split accept & non-accept
        auto result              = std::vector<std::vector<int>>();
        auto total_accept_status = std::set<int>();
        for (int i = 0; i < dfa._total_status; ++i) {
            total_accept_status.insert(dfa._accept_status[i]);
        }
        for (auto accept_status : total_accept_status) {
            std::vector<int> tmp_group;
            for (int i = 0; i < dfa._total_status; ++i) {
                if (dfa._accept_status[i] == accept_status) {
                    tmp_group.push_back(i);
                }
            }
            result.push_back(tmp_group);
        }
        return result;
    }

    static std::vector<std::vector<int>> split_group(fa dfa, std::vector<std::vector<int>> input) {
        std::vector<std::vector<int>> result;
        std::vector<std::vector<int>> last_result;
        std::vector<std::vector<int>> this_result;
        do {
            last_result = this_result;
            this_result.clear();
            for (char ch : dfa._symbols) {
                for (auto group : input) {
                    std::vector<int> dest_groups;
                    for (auto state : group) {
                        int dest_state = -1;
                        int dest_group = -1;
                        for (int i = dfa._head[state]; i != -1; i = dfa._edge[i]._next) {
                            if (dfa._edge[i]._ch == ch) {
                                dest_state = dfa._edge[i]._to;
                                break;
                            }
                        }
                        if (dest_state != -1) {
                            for (auto i = 0; i < input.size(); ++i)
                                for (auto j : input[i])
                                    if (dest_state == j)
                                        dest_group = i;
                        }
                        dest_groups.push_back(dest_group);
                    }
                    // split
                    std::set<int> dests(dest_groups.begin(), dest_groups.end());
                    for (auto dest : dests) {
                        std::vector<int> tmp_group;
                        for (int i = 0; i < dest_groups.size(); ++i) {
                            if (dest_groups[i] == dest) {
                                tmp_group.push_back(group[i]);
                            }
                        }
                        this_result.push_back(tmp_group);
                    }
                }
                input = this_result;
                this_result.clear();
            }
            this_result = input;
        } while (this_result != last_result);
        return input;
    }

    static int in_which_group(std::vector<std::vector<int>> groups, int state) {
        for (int i = 0; i < groups.size(); ++i) {
            for (auto e : groups[i]) {
                if (e == state)
                    return i;
            }
        }
        return -1;
    }

    static std::vector<std::vector<int>> move_forward_zero(std::vector<std::vector<int>> groups) {
        int i = 0;
        for (; i < groups.size(); ++i) {
            for (auto state : groups[i])
                if (state == 0)
                    goto find_zero;
        }
    find_zero:
        std::swap(groups[0], groups[i]);
        return groups;
    }
};

// runner.hpp

struct runnable_fa {
    runnable_fa(fa f) : _fa(f), _current_state(0) {}
    fa  _fa;
    int _current_state;
    // return value:
    // false: failed, true: find
    bool input(char ch) {
        for (int i = _fa._head[_current_state]; i != -1; i = _fa._edge[i]._next) {
            if (_fa._edge[i]._ch == ch) {
                _current_state = _fa._edge[i]._to;
                return true;
            }
        }
        return false;
    }

    void reset() {
        _current_state = 0;
    }
};

class runner {
public:
    // return value:
    // -1: failed, 0: eof
    static int run(fa f, std::string s, std::map<int, std::function<void(void)>> table) {
        int  pos     = 0;
        auto exec    = runnable_fa(f);
        bool reseted = true;
        while (pos < s.length()) {
            bool can_we_put_it_in = exec.input(s[pos]);

            if (can_we_put_it_in == false) {
                // time to check current state
                int result = exec._fa._accept_status[exec._current_state];
                if (result == -1) {
                    // looks like it failed :(
                    if (reseted)
                        return -1;
                    else {
                        exec.reset();
                        reseted = true;
                        continue;
                    }
                }
                // ok, match, reset it and retry!
                table[result]();
                exec.reset();
                reseted = true;
                continue;
            }

            if (pos == s.length() - 1) {
                int result = exec._fa._accept_status[exec._current_state];
                if (result == -1) {
                    return -1;
                }
                table[result]();
            }

            pos++;
            reseted = false;
        }
        return 0;
    }
};

// lex.hpp

class lex {
public:
    lex() : _total_enums(101) {}

    void add_regexpr(std::string reg, std::function<void(void)> func) {
        _regs.push_back(std::tuple<std::string, std::function<void(void)>, int>(reg, func, _total_enums++));
    }

    void execute(std::string prog) {
        std::map<int, std::function<void(void)>> table;
        std::vector<fa>                          fas;
        for (auto it : _regs) {
            table[std::get<2>(it)] = std::get<1>(it);
            auto reg_s             = regexpr::convert(std::get<0>(it));
            auto nfa               = nfa::convert(reg_s, std::get<2>(it));
            fas.push_back(nfa);
        }
        auto combined = nfa::combine_nfas(fas);
        auto fin_dfa  = dfa::convert(combined);
        auto min_dfa  = minimize_dfa::convert(fin_dfa);

        int res = runner::run(min_dfa, prog, table);
        if (res == -1) {
            exit(1);
        }
        // std::cout << "EOF" << std::endl;
    }

private:
    int _total_enums;

    std::vector<std::tuple<std::string, std::function<void(void)>, int>> _regs;
};

// user_function.cpp

std::string yyin;
std::string file_content;

void load_file() {
    std::ifstream      fs(yyin);
    std::ostringstream oss;
    oss << fs.rdbuf();
    file_content = oss.str();
    fs.close();
}

void read_from_input() {
    std::string s;
    while (std::cin >> s) {
        file_content += s;
        file_content += "\n";
    }
}

// Here's what we need to replace
void yylex() {
    if (yyin != "") {
        load_file();
    }
    else {
        read_from_input();
    }
    lex lexer;
    // INSERT RULE HERE
    lexer.execute(file_content);
}